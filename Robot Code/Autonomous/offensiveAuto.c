#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     sLiftStop,      sensorTouch)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
		// 1 wheel rot = 1350 ticks
#include "JoystickDriver.c"
#include "autonomous-includes/autonomous_tasks.h"
#include "autonomous-includes/autoMenu.h"

const int irThresh = 225;

void initializeRobot(){
	doIr = true;
	goAround = false;
	startNear = false;
	rampOtherSide = false;
	allMotorsTo(0);
}

task main(){

	nMotorEncoder[mDriveLeft] = 0;
	clearDebugStream();
	StartTask(runMenuOffensive);
	initializeRobot();

	waitForStart();
	StartTask(showDebugInfo);
	StartTask(getSmux);

	// Is there a delay?
	if(delay > 0){
		writeDebugStreamLine("Wait detected");
		wait10Msec(delay * 100);		// Wait the amount of time given by the delay
		writeDebugStreamLine("Wait over");
	}

	// Are we going to place the block?
	int basketPosition = 0;
	if(doIr){
		writeDebugStreamLine("Going for IR");
		// Move up to the first basket
		goTicks(inchesToTicks(3.5), 100);
		writeDebugStreamLine("At first basket");
		// Record the encoder value at the first basket
		long startEncoderPos = nMotorEncoder[mDriveRight];
		// Loop four times
		for(int i = 1; i <= 4; i++){
			// If the ir seeker value is over the threshold
			writeDebugStreamLine("Basket#%d:IR Value = %d, need %d to stop", i, (irStrengthLeft > irStrengthRight) ? irStrengthLeft : irStrengthRight, irThresh);
			if(irStrengthLeft > irThresh || irStrengthRight > irThresh){
				placeBlock(i);					// Place the block
				basketPosition = i;		// Return the current basket position
				writeDebugStreamLine("Placing block");
				break;								// Break out of the loop
			}
			// If the ir seeker value is below the threshold
			else{
				//long blockDistances[3] = {inchesToTicks(10), inchesToTicks(23), inchesToTicks(10)};
				//// Move forward the distance corresponding to the current basket
				//goTicks(blockDistances[i-1], 50);

				// Move forward the amount of ticks needed to reach the next programmed value
				long blockDistancesCumulative[3] = {startEncoderPos + inchesToTicks(10), startEncoderPos + inchesToTicks(33), startEncoderPos + inchesToTicks(43)};
				// Go destination minus current ticks
				goTicks(blockDistancesCumulative[i-1] - nMotorEncoder[mDriveRight], 100);
			}
		}

		// Are we going around the far end?
		if(goAround){
			writeDebugStreamLine("Going to far end of ramp");
			// Figure out how far we have to go to get to the far end of the ramp, and go that distance
			long farEncoderPos = startEncoderPos + inchesToTicks(65);
			goTicks(farEncoderPos - nMotorEncoder[mDriveRight], 100);
		}else{
			writeDebugStreamLine("Going to near end of ramp");
			// Figure out how far back we have to go to get to the near end of the ramp, and go that distance
			long nearEncoderPos = startEncoderPos - inchesToTicks(7);
			goTicks(-1 * (nMotorEncoder[mDriveRight] - nearEncoderPos), 100);
		}

		// Did we start near or far?
		if(startNear){
			// Turn clockwise
			turnDegrees(-90, 35);
			if(rampOtherSide)
				goTicks(inchesToTicks(36), 100);
			findWhiteLine();
			turnDegrees(90, 35);
		}else{
			// Turn counterclockwise
			turnDegrees(90, 35);
			if(rampOtherSide)
				goTicks(inchesToTicks(36), 100);
			findWhiteLine();
			turnDegrees(-90, 35);
		}

		// Go up the ramp
		goTicks(1350, 100);
	}
}
