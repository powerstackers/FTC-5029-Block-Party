#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     TMUX,           sensorAnalogInactive)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "autonomous-includes/autonomous_tasks.c"

task main(){
	StartTask(showDebugInfo);
	nMotorEncoder[mDriveLeft] = 0;
	long encoderHome = nMotorEncoder[mDriveLeft];
	clearDebugStream();
	StartTask(getSmux);

	if(touchInput3){		// If the "wait" button is activated
		wait10Msec(1000);
	}

	if(touchInput2){		// If the "far corner/near corner" button is activated
		findIrRight(60, 25, 25);	// Find the IR signal using the left sensor
		placeBlock(1);						// Place the block in the basket
	}else{
		findIrLeft(25, 25, 25);		// Find the IR signal using the right sensor
		placeBlock(-1);						// Place the block in the basket
	}

	if(touchInput1){		// If we're going for the near side of the ramp
		returnToSpot(1, encoderHome);	// Return to the original position before turning
	}

	if(!touchInput2){		// If we're starting from the near side
		turnDegrees(90);
	}else{
		turnDegrees(-90);
	}

	findWhiteLine(false, 1);

	if(!touchInput2){
		turnDegrees(90);
	}else{
		turnDegrees(-90);
	}

	goFeet(2, 100);

}
