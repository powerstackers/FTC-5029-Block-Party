#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     sLiftStop,      sensorTouch)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
		// 1 wheel rot = 1350 ticks
#include "JoystickDriver.c"
#include "autonomous-includes/autonomous_tasks.h"
#include "autonomous-includes/autoMenu.h"

const int irThresh = 225;

void initializeRobot(){
	doIr = true;
	goAround = false;
	startNear = false;
}

task main(){
	StartTask(showDebugInfo);
	nMotorEncoder[mDriveLeft] = 0;
	clearDebugStream();
	StartTask(getSmux);

	initializeRobot();
//	waitForStart();

	// Is there a delay?
	if(delay > 0){
		writeDebugStreamLine("Wait detected");
		wait10Msec(delay * 100);		// Wait the amount of time given by the delay
		writeDebugStreamLine("Wait over");
	}

	// Are we going to place the block?
	int basketPosition = 0;
	if(doIr){
		writeDebugStreamLine("Going for IR");
		// Move up to the first basket
		goTicks(inchesToTicks(3.5), 100);
		writeDebugStreamLine("At first basket");
		// Record the encoder value at the first basket
		long startEncoderPos = nMotorEncoder[mDriveRight];
		// Loop four times
		for(int i = 1; i <= 4; i++){
			// If the ir seeker value is over the threshold
			writeDebugStreamLine("Basket#%d:IR Value = %d, need %d to stop", i, (irStrengthLeft > irStrengthRight) ? irStrengthLeft : irStrengthRight, irThresh);
			if(irStrengthLeft > irThresh || irStrengthRight > irThresh){
				placeBlock(i);					// Place the block
				basketPosition = i;		// Return the current basket position
				writeDebugStreamLine("Placing block");
				break;								// Break out of the loop
			}
			// If the ir seeker value is below the threshold
			else{
				long blockDistances[3] = {inchesToTicks(10), inchesToTicks(23), inchesToTicks(10)};
				// Move forward the distance corresponding to the current basket
				goTicks(blockDistances[i-1], 50);

				// Move forward the amount of ticks needed to reach the next programmed value
				long blockDistancesCumulative[3] = {startEncoderPos + inchesToTicks(10), startEncoderPos + inchesToTicks(33), startEncoderPos + inchesToTicks(43)};
				// Go destination minus current ticks
				goTicks(blockDistancesCumulative[i-1] - nMotorEncoder[mDriveRight], 100);
			}
		}

		// Are we going around the far end?
		if(goAround){
			writeDebugStreamLine("Going to far end of ramp");
		//	// Loop through and move forward until we're past the baskets
		//	for(int i = 0; i < (3 - basketPosition); i++){
		//		goTicks(1350, 100);
		//	}
		//	// Move to turning position
		//	goTicks(1350, 100);
		//}else{
		//	// Loop through and move backward until we're past the baskets
		//	for(int i = 0; i < basketPosition; i++){
		//		goTicks(-1350, 100);
		//	}

		//	// Move to turning position
		//	goTicks(-1350, 100);
		//}

		//// Did we start near or far?
		//if(startNear){
		//	// Turn clockwise
		//	turnDegrees(-90, 35);
		//	goTicks(1350, 100);
		//	turnDegrees(90, 35);
		//}else{
		//	// Turn counterclockwise
		//	turnDegrees(90, 35);
		//	goTicks(1350, 100);
		//	turnDegrees(-90, 35);
		//}

		//// Go up the ramp
		//goTicks(1350, 100);
	}
}}
