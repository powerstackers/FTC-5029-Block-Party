#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRS_R,          sensorI2CCustom)
#pragma config(Sensor, S4,     IRS_L,          sensorI2CCustom)
#pragma config(Motor,  motorA,          mBlockStop,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define STICK_TO_MOTOR(x)	((float)x * 0.78125)	// Convert the joystick's -128 - 127 value to a -99 - 100 value
#define MODE_STRAIGHT true					// Drive modes, straight or tank
#define MODE_NORMAL false

// Set all motors to the input value
void allMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
		motor[mBsAngle] 		= i;
		motor[mBsConveyor] 	= i;
}

// Set all drive motors to the input value
void driveMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
}

// Initialize robot positions
void initializeRobot()
{
	allMotorsTo(0);
  return;
}

// Global Variable declarations



// Function to transfer normal joystick values to the custom variables
void getCustomJoystickSettings(){
	stickDriveLeft 	= joystick.joy1_y1;
	stickDriveRight = joystick.joy1_y2;
	stickConveyor		=	joystick.joy2_y2;
	stickAngle			= joystick.joy2_y1;
	btnStraightDr		= (joy1Btn(3) == 1);
	btnBlockStop		=	(joy2Btn(3) == 1);
}

// Print information to the screen
void displayButtonValues(){
	  nxtDisplayTextLine(0, "stDriveLeft:%d",		stickDriveLeft);	// Left drive joystick
  	nxtDisplayTextLine(1, "stDriveRight:%d",	stickDriveRight);	// Right drive joystick
		nxtDisplayTextLine(3, "btnBlockStop:%s", (btnBlockStop)?"ON":"OFF");	// Brick stopper button

  	nxtDisplayTextLine(5, "DriveMode:%s",			(driveMode)?"STRAIGHT":"NORMAL");	// Selected drive mode
		nxtDisplayTextLine(6, "stickAngle:%d", stickAngle);	// Brick sucker joystick
		nxtDisplayTextLine(7, "stickConveyor:%d", stickConveyor);	// Conveyor joystick
}

// Move the block breaker without stopping the program
task moveBrickBlocker(){
	blockerMoving = true; // Raise the blockerMoving flag
	if(brickBlocked){
		while(nMotorEncoder[mBlockStop] < (encoderStartValue + blockOpenPos)){	// While motor has not reached encoder position
			motor[mBlockStop] = 25;
		}
		writeDebugStreamLine("current encoder value: %d at end", nMotorEncoder[mBlockStop]);
		motor[mBlockStop] = 0;
		brickBlocked = false; // Blocker is now open, toggle flag
	}else{
		while(nMotorEncoder[mBlockStop] > (encoderStartValue + blockClosedPos)){ // While motor has not reached encoder position
			motor[mBlockStop] = -25;
		}
		writeDebugStreamLine("current encoder value: %d at end", nMotorEncoder[mBlockStop]);
		motor[mBlockStop] = 0;
		brickBlocked = true;	// Blocker is now closed, toggle flag
		writeDebugStreamLine("brickBlocked toggled: true\n closed blocker");
	}
	blockerMoving = false; // Toggle off the task flag, and end
	writeDebugStreamLine("Stopped task: moveBrickBlocker");
	return;
}

task main(){
	// Turn off battery level display on the NXT screen
	bNxtLCDStatusDisplay = false;

	eraseDisplay();		// Cear the screen
  initializeRobot();
  ClearTimer(T1);	// Reset the timer

  //waitForStart();   // wait for start of tele-op phase

  while (true){
  	getJoystickSettings(joystick);
  	getCustomJoystickSettings();		// Fetch the joystick information
		displayButtonValues();


		// Changing drive mode
		if(btnStraightDr){
			driveMode = MODE_STRAIGHT;
			//writeDebugStreamLine("Changed mode to straight");
		}
		else{
			driveMode = MODE_NORMAL;
			//writeDebugStreamLine("Changed mode to normal");
		}


		// Straight drive mode
		if (driveMode == MODE_STRAIGHT){

			// STRAIGHT DRIVE
			if(abs(stickDriveLeft) > stickThreshold){
					driveMotorsTo(STICK_TO_MOTOR(stickDriveLeft));
			}
			else{
				driveMotorsTo(0);
			}

		}
		// Normal drive mode
		else if(driveMode == MODE_NORMAL){

			// LEFT DRIVE
			if(abs(stickDriveLeft) < stickThreshold){
				motor[mDriveLeft] = 0;
			}
			else{
				motor[mDriveLeft] = STICK_TO_MOTOR(stickDriveLeft);
			}

			// RIGHT DRIVE
			if(abs(stickDriveRight) < stickThreshold){
				motor[mDriveRight] = 0;
			}
			else{
				motor[mDriveRight] = STICK_TO_MOTOR(stickDriveRight);
			}
		}


		// Conveyor
		if(abs(stickConveyor) < stickThreshold){
			motor[mBsConveyor] = 0;
		}
		else{
			motor[mBsConveyor] = ((stickConveyor > 0)? 100 : -100);	// Do not scale the motor speed. +100 or -100 only.
		}


		// Brick Sucker raise/lower
		if(abs(stickAngle) < stickThreshold){
			motor[mBsAngle] = 0;
		}
		else{
			motor[mBsAngle] = ((stickAngle > 0)? 100 : -100);
		}

		// Brick stopper servo
		if(btnBlockStop){
			if(time100[T1] % 10 == 0){
				//brickBlocked = !brickBlocked;	// Switch the brickSucker
				if(!blockerMoving)
					blockerMoving = true;
					StartTask(moveBrickBlocker);
			}
		}
  }
}
