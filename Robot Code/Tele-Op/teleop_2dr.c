#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRS_R,          sensorI2CCustom)
#pragma config(Sensor, S4,     IRS_L,          sensorI2CCustom)
#pragma config(Motor,  motorA,          mBlockStop,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define FN(x)	((float)x * 0.78125)	// Convert the joystick's -128 - 127 value to a -99 - 100 value
#define MODE_STRAIGHT true
#define MODE_NORMAL false

// Set all motors to the input value
void allMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
		motor[mBsAngle] 		= i;
		motor[mBsConveyor] 	= i;
}

// Set all drive motors to the input value
void driveMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
}

// Initialize robot positions
void initializeRobot()
{
	allMotorsTo(0);
  return;
}

// Global Variable declarations
short 	stickDriveLeft;
short 	stickDriveRight;
short		stickConveyor;
short		stickAngle;

bool 		btnBsPower;
bool 		btnBsReverse;
bool 		btnBsRaise;
bool 		btnStraightDr;
bool		btnBlockStop;
bool		driveMode;
bool		brickBlocked;
bool		blockerMoving;

const short		stickThreshold = 10;
const int			blockClosedPos = 0;
const int			blockOpenPos = 90;

// Function to transfer normal joystick values to the custom variables
void getCustomJoystickSettings(){
	stickDriveLeft 	= joystick.joy1_y1;
	stickDriveRight = joystick.joy1_y2;
	stickConveyor		=	joystick.joy2_y2;
	stickAngle			= joystick.joy2_y1;
	btnStraightDr		= (joy1Btn(3) == 1);
	btnBlockStop		=	(joy2Btn(3) == 1);
}

// Print information to the screen
void displayButtonValues(){
	  nxtDisplayTextLine(0, "stDriveLeft:%d",		stickDriveLeft);
  	nxtDisplayTextLine(1, "stDriveRight:%d",	stickDriveRight);
  	nxtDisplayTextLine(2, "btnBsPower:%s",		(btnBsPower)?"1":"0");
  	nxtDisplayTextLine(3, "btnBsReverse:%s",	(btnBsReverse)?"1":"0");
  	nxtDisplayTextLine(4, "btnBsRaise:%s",		(btnBsRaise)?"1":"0");
  	nxtDisplayTextLine(5, "DriveMode:%s",			(driveMode)?"STRAIGHT":"NORMAL");
  	nxtDisplayTextLine(6, "mDrLeft:%3.1f",		motor[mDriveLeft]);
  	nxtDisplayTextLine(7, "mDrRight:%3.1f",		motor[mDriveRight]);
}

// Move the block breaker without stopping the program
task moveBrickBlocker(){
	blockerMoving = true;
	if(brickBlocked){
		while(nMotorEncoder[mBlockStop] < blockOpenPos){
			motor[mBlockStop] = 100;
		}
		motor[mBlockStop] = 0;
	}else{
		while(nMotorEncoder[mBlockStop] > blockClosedPos){
			motor[mBlockStop] = -100;
		}
		motor[mBlockStop] = 0;
	}
	blockerMoving = false;
}

task main(){
	// Turn off battery level display on the NXT screen
	bNxtLCDStatusDisplay = false;

	eraseDisplay();		// Cear the screen
  initializeRobot();
  ClearTimer(T1);

  //waitForStart();   // wait for start of tele-op phase

  while (true){
  	getJoystickSettings(joystick);
  	getCustomJoystickSettings();
		displayButtonValues();


		// Changing drive mode
		if(btnStraightDr){
			driveMode = MODE_STRAIGHT;
			writeDebugStreamLine("Changed mode to straight");
		}
		else{
			driveMode = MODE_NORMAL;
			writeDebugStreamLine("Changed mode to normal");
		}


		// Straight drive mode
		if (driveMode == MODE_STRAIGHT){

			// STRAIGHT DRIVE
			if(abs(stickDriveLeft) > stickThreshold){
					driveMotorsTo(FN(stickDriveLeft));
			}
			else{
				driveMotorsTo(0);
			}

		}
		// Normal drive mode
		else if(driveMode == MODE_NORMAL){

			// LEFT DRIVE
			if(abs(stickDriveLeft) < stickThreshold){
				motor[mDriveLeft] = 0;
			}
			else{
				motor[mDriveLeft] = FN(stickDriveLeft);
			}

			// RIGHT DRIVE
			if(abs(stickDriveRight) < stickThreshold){
				motor[mDriveRight] = 0;
			}
			else{
				motor[mDriveRight] = FN(stickDriveRight);
			}
		}


		// Conveyor
		if(abs(stickConveyor) < stickThreshold){
			motor[mBsConveyor] = 0;
		}
		else{
			motor[mBsConveyor] = FN(stickConveyor);
		}


		// Brick Sucker raise/lower
		if(abs(stickConveyor) < stickThreshold){
			motor[mBsAngle] = 0;
		}
		else{
			motor[mBsAngle] = FN(stickConveyor);
		}

		// Brick stopper servo
		if(btnBlockStop){
			if(time100[T1] % 10 == 0){
				brickBlocked = !brickBlocked;	// Switch the brickSucker
				if(!blockerMoving)
					StartTask(moveBrickBlocker);
			}
		}
  }
}
