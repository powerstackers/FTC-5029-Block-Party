#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRS_R,          sensorI2CCustom)
#pragma config(Sensor, S4,     IRS_L,          sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define STICK_TO_MOTOR(x)	((float)x * 0.78125)	// Convert the joystick's -128 - 127 value to a -99 - 100 value
#define MODE_STRAIGHT true					// Drive modes, straight or tank
#define MODE_NORMAL false

// Global variables
short 	stickDriveLeft;		// Analog joysticks
short 	stickDriveRight;
short		stickAngle;
short		stickBlockStop;

bool 		btnStraightDr;		// Single-bit buttons
bool		btnConveyor;
bool		btnReverse;

bool		driveMode;				// Flags
bool		brickBlocked = true;
bool		blockerMoving = false;

const short		stickThreshold = 10;	// Constants
const short 	encoderStartValue = nMotorEncoder[mBlockStop];
const int			blockClosedPos = 90;
const int			blockOpenPos = -5;
const int 		blockOpenThresh = -360;
const int 		blockClosedThresh = 360;
const int			blockSpeed = 25;

// Set all motors to the input value
void allMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
		motor[mBsAngle] 		= i;
		motor[mBsConveyor] 	= i;
}

// Set all drive motors to the input value
void driveMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
}

void allEncodersTo(int i){
	nMotorEncoder[mBlockStop] = i;
	nMotorEncoder[mBsAngle] = i;
	nMotorEncoder[mBsConveyor] = i;
	nMotorEncoder[mDriveLeft] = i;
	nMotorEncoder[mDriveRight] = i;
	writeDebugStreamLine("Encoders initialized");
}

// Initialize robot positions
void initializeRobot()
{
	allMotorsTo(0);
	allEncodersTo(0);
  return;
}


// Function to transfer normal joystick values to the custom variables
void getCustomJoystickSettings(){
	stickDriveLeft 	= joystick.joy1_y1;
	stickDriveRight = joystick.joy1_y2;
	btnConveyor		=	(joy1Btn(6) == 1);
	stickAngle			= joystick.joy2_y1;
	btnStraightDr		= (joy1Btn(3) == 1);
	stickBlockStop	=	joystick.joy2_y2;
	btnReverse			= (joy2Btn(8) == 1);
}

// Print information to the screen
void displayButtonValues(){
	  nxtDisplayTextLine(0, "stDriveLeft:%d",		stickDriveLeft);	// Left drive joystick
  	nxtDisplayTextLine(1, "stDriveRight:%d",	stickDriveRight);	// Right drive joystick
		nxtDisplayTextLine(3, "stickBlSt:%d", stickBlockStop);	// Brick stopper button
		nxtDisplayTextLine(4, "mtrBlock:%d", motor[mBlockStop]);
  	nxtDisplayTextLine(5, "blEnc:%d", nMotorEncoder[mBlockStop]);	// Encoder on NXT motor
		nxtDisplayTextLine(6, "stickAngle:%d", stickAngle);	// Brick sucker joystick
		//nxtDisplayTextLine(7, "btnConveyor:%d", btnConveyor);	// Conveyor joystick
}

task main(){
	// Turn off battery level display on the NXT screen
	bNxtLCDStatusDisplay = false;
  clearDebugStream();
	eraseDisplay();		// Cear the screen
  initializeRobot();
  ClearTimer(T1);	// Reset the timer


  //waitForStart();   // wait for start of tele-op phase

  while (true){
  	getJoystickSettings(joystick);
  	getCustomJoystickSettings();		// Fetch the joystick information
		displayButtonValues();


		// Changing drive mode
		if(btnStraightDr){
			driveMode = MODE_STRAIGHT;
			//writeDebugStreamLine("Changed mode to straight");
		}
		else{
			driveMode = MODE_NORMAL;
			//writeDebugStreamLine("Changed mode to normal");
		}


		// Straight drive mode
		if (driveMode == MODE_STRAIGHT){

			// STRAIGHT DRIVE
			if(abs(stickDriveLeft) > stickThreshold){
					driveMotorsTo(STICK_TO_MOTOR(stickDriveLeft));
			}
			else{
				driveMotorsTo(0);
			}

		}
		// Normal drive mode
		else if(driveMode == MODE_NORMAL){

			// LEFT DRIVE
			if(abs(stickDriveLeft) < stickThreshold){
				motor[mDriveLeft] = 0;
			}
			else{
				motor[mDriveLeft] = STICK_TO_MOTOR(stickDriveLeft);
			}

			// RIGHT DRIVE
			if(abs(stickDriveRight) < stickThreshold){
				motor[mDriveRight] = 0;
			}
			else{
				motor[mDriveRight] = STICK_TO_MOTOR(stickDriveRight);
			}
		}


		// Conveyor
		if(btnConveyor){
			motor[mBsConveyor] = 100;
		}
		else if(btnReverse){
			motor[mBsConveyor] = -100;
		}else{
			motor[mBsConveyor] = 0;
		}


		// Brick Sucker raise/lower
		if(abs(stickAngle) < stickThreshold){
			motor[mBsAngle] = 0;
		}
		else{
			motor[mBsAngle] = ((stickAngle > 0)? 100 : -100);
		}

		// Brick stopper servo
		if(abs(stickBlockStop) < stickThreshold){
			motor[mBlockStop] = 0;
		}else if(nMotorEncoder[mBlockStop] >= blockOpenThresh && stickBlockStop > 0){
				if(nMotorEncoder[mBlockStop] < blockClosedPos){
					motor[mBlockStop] = blockSpeed;
				}else{
					motor[mBlockStop] = 0;
				}
		}else if(nMotorEncoder[mBlockStop] <= blockClosedThresh && stickBlockStop < 0){
			if(nMotorEncoder[mBlockStop] > blockOpenPos){
				motor[mBlockStop] = blockSpeed * -1;
			}else{
				motor[mBlockStop] = 0;
			}
		}else{
			motor[mBlockStop] = 0;
		}
  }
}
