#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     sConvStop,      sensorTouch)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    rConveyorTight,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    rBlockDropLeft,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    rBlockDropRight,      tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	TELE-OP CODE FOR FTC# 5029
//	2013-2014 BLOCK PARTY
//	UPDATED 3-23-14
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  																					//Include file to "handle" the Bluetooth messages.

// Define constants
#define STICK_TO_MOTOR(x)	((float)x * 0.78125)												// Convert the joystick's -128 - 127 value to a -99 - 100 value
#define MODE_STRAIGHT true																						// Drive modes, straight or normal
#define MODE_NORMAL false
																																			// --GLOBAL VAIRABLES
																																			// ANALOG JOYSTICKS
short 	stickDriveLeft;																								// Left drive motor
short 	stickDriveRight;																							// Right drive motor
short		stickAngle;																										// Block sucker up/down
short		stickBlockStop;																								// Block gate motor

																																			// SINGLE-BIT BUTTONS
bool 		btnStraightDr;																								// Activate straight drive
bool		btnConveyor;																									// Activate the conveyor (up)
bool		btnReverse;																										// Activate the conveyor (down)
bool		btnBlockStop;																									// Activate the block stopper
bool		btnFlagClock;																									// Activate the flag raiser (clockwise)
bool		btnFlagCounter;																								// Activate the flag raiser (counter-clockwise)
bool		btnConveyorTight;																							// Activate the conveyor tensioner

																																			// FLAGS
bool		driveMode;																										// Drive mode set to straight or normal
bool		brickBlocked = true;																					// Whether or not the brick blocker is activated
bool		blockerMoving = false;																				// Whether or not the brick blocker is moving

																																			// CONSTANTS
const short		stickThreshold = 10;																		// Value that sticks must pass to be considered active
const int			blockClosedPos = 90;																		// Closed position encoder value for the brick blocker
const int			blockOpenPos = -5;																			// Open position encoder value for the brick blocker
const int 		blockOpenThresh = -360;																	// Encoder value below which the brick blocker will not continue
const int 		blockClosedThresh = 360;																// Encoder value above which the brick blocker will not continue
const int			blockSpeed = 50;																				// Motor speed for the brick blocker

																																			// --SET ALL MOTORS TO INPUT VALUE
void allMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
		motor[mBsAngle] 		= i;
		motor[mBsConveyor] 	= i;
}
																																			// --SET ALL DRIVE MOTORS TO INPUT VALUE
void driveMotorsTo(int i){
		motor[mDriveLeft] 	= i;
		motor[mDriveRight] 	= i;
}
																																			// --SET ALL ENCODERS TO INPUT VALUE
void allEncodersTo(int i){
	nMotorEncoder[mBlockStop] = i;
	nMotorEncoder[mBsAngle] = i;
	nMotorEncoder[mBsConveyor] = i;
	nMotorEncoder[mDriveLeft] = i;
	nMotorEncoder[mDriveRight] = i;
	writeDebugStreamLine("Encoders initialized");
}
																																			// --INITIALIZE ROBOT
void initializeRobot()
{
	allMotorsTo(0);
	allEncodersTo(0);
	servo[rBlockDropleft] = 128;
	servo[rBlockDropRight] = 128;
	servo[rConveyorTight] = 150;
  return;
}
																																			// --GET CUSTOM JOYSTICK SETTINGS
void getCustomJoystickSettings(){
	stickDriveLeft 	= joystick.joy1_y1;																	// dr1 left joystick
	stickDriveRight = joystick.joy1_y2;																	// dr1 right joystick
	stickAngle			= joystick.joy2_y1;																	// dr2 left joystick
	stickBlockStop	=	joystick.joy2_y2;																	// dr2 right joystick
	btnStraightDr		= (joy1Btn(3) == 1);																// dr1 red button
	btnFlagClock		= (joy1Btn(5) == 1);																// dr1 left shoulder
	btnFlagCounter	= (joy1Btn(7) == 1);																// dr1 left trigger
	btnReverse			= (joy2Btn(8) == 1);																// dr2 right trigger
	btnConveyor			=	(joy2Btn(6) == 1);																// dr2 right shoulder
	btnConveyorTight =(joy2Btn(7) == 1);																// dr2 left trigger
	btnBlockStop 		= (joy2Btn(3) == 1);
}
																																			// --PRINT INFO TO THE SCREEN
void displayButtonValues(){
	  nxtDisplayTextLine(0, "btnBlockStop:%d",		btnBlockStop);				// Left drive joystick
  	nxtDisplayTextLine(1, "blockStop enc: %d",	nMotorEncoder[mBlockStop]);// Right drive joystick
		nxtDisplayTextLine(3, "stickBlSt:%d", stickBlockStop);						// Brick stopper button
		nxtDisplayTextLine(4, "mtrBlock:%d", motor[mBlockStop]);
  	nxtDisplayTextLine(5, "bsAngle:%d", nMotorEncoder[mBsAngle]);			// Encoder on NXT motor
		nxtDisplayTextLine(6, "stickAngle:%d", stickAngle);								// Brick sucker joystick
		nxtDisplayTextLine(7, "btnBlockStop:%d", btnBlockStop);						// Conveyor joystick
}
																																			// --MAIN TASK
task main(){
																																			// Do some housekeeping:
	bDisplayDiagnostics = false;																				// Turn off battery level display on the NXT screen
  clearDebugStream();																									// Clear the debug screen from last time
	eraseDisplay();																											// Cear the screen
  initializeRobot();																									// Initialize all the motors and servos
  ClearTimer(T1);																											// Reset the timer

  waitForStart();   																									// wait for start of tele-op phase

  while (true){																												// Loop forever:
  	getJoystickSettings(joystick);																		// Get the regular joystick information
  	getCustomJoystickSettings();																			// Get the custom joystick information
		displayButtonValues();																						// Print it all on the NXT screen

																																			// Change drive mode:
		if(btnStraightDr){																								// If the straight drive button is pressed:
			driveMode = MODE_STRAIGHT;																			// Switch to straight drive mode
		}else{																														// If the straight drive button is NOT pressed:
			driveMode = MODE_NORMAL;																				// Switch to normal drive mode
		}

		if (driveMode == MODE_STRAIGHT){																	// Straight drive mode:
			if(abs(stickDriveLeft) > stickThreshold){												// If the stick is pushed past the threshold:
					driveMotorsTo(STICK_TO_MOTOR(stickDriveLeft));							// Move both motors at the same speed
			}else{																													// If the stick is NOT pushed past the threshold:
				driveMotorsTo(0);																							// Stop drive motors
			}
		}

		else if(driveMode == MODE_NORMAL){																// Normal drive mode:

																																			// LEFT
			if(abs(stickDriveLeft) < stickThreshold){												// If the stick is NOT pushed past the threshold:
				motor[mDriveLeft] = 0;																				// Stop the motor
			}else{																													// If the stick is pushed past the threshold:
				motor[mDriveLeft] = STICK_TO_MOTOR(stickDriveLeft);						// Left drive motor to a function of the stick value
			}
																																			// RIGHT
			if(abs(stickDriveRight) < stickThreshold){											// IF the stick is NOT pushed past the threshold:
				motor[mDriveRight] = 0;																				// Stop the motor
			}else{																													// If the stick is pushed past the threshold:
				motor[mDriveRight] = STICK_TO_MOTOR(stickDriveRight);					// Right drive motor to a function of the stick value
			}
		}
																																			// CONVEYOR
		if(btnConveyor){																									// If the conveyor button is pressed:
			motor[mBsConveyor] = 100;																				// Conveyor motor to 75
		}else if(btnReverse){																							// If the reverse conveyor button is pressed:
			motor[mBsConveyor] = -100;																				// Conveyor motor to -75
		}else{																														// If NEITHER button is pressed:
			motor[mBsConveyor] = 0;																					// Conveyor motor to 0
		}
																																			// BRICK SUCKER
		if(abs(stickAngle) < stickThreshold){															// If the stick is NOT pushed past the threshold:
			motor[mBsAngle] = 0;																						// Brick sucker motor to 0
		}else{																														// If the stick is pushed past the threshold:
			if(stickAngle < 0 && SensorValue[sConvStop] == 1){							// If the stick is being pushed down and the stop sensor is activated:
				motor[mBsAngle] = 0;																					// Turn off the motor
				nMotorEncoder[mBsAngle] = 0;																	// Set the motor encoder back to 0
			}
			else																														// If the stick is activated and the stop sensor is not activated:
				motor[mBsAngle] = ((stickAngle > 0)? 100 : -100);							// If the stick value is positive, motor to 100. If it is negative, motor to -100
		}
																																			// BLOCK GATE
		if(abs(stickBlockStop) < stickThreshold){													// If the stick is NOT pushed past the threshold:
			motor[mBlockStop] = 0;																					// Gate motor to 0
		}else if(nMotorEncoder[mBlockStop] >= blockOpenThresh 						// If the encoder value is above a threshold, AND the stick is above the threshold:
			&& stickBlockStop > 0){
				if(nMotorEncoder[mBlockStop] < blockClosedPos){								// If the motor encoder is below a threshold:
					motor[mBlockStop] = blockSpeed;															// Set the motor to the block speed
				}else{																												// If the motor encoder is past a threshold:
					motor[mBlockStop] = 0;																			// Stop the motor
				}
		}else if(nMotorEncoder[mBlockStop] <= blockClosedThresh						// If the encoder value is below a theshold, AND the stick is above the threshold:
			&& stickBlockStop < 0){
			if(nMotorEncoder[mBlockStop] > blockOpenPos){										// If the motor encoder is above a threshold:
				motor[mBlockStop] = blockSpeed * -1;													// Set the motor to the block speed
			}else{																													// If the motor encoder is past a threshold:
				motor[mBlockStop] = 0;																				// Stop the motor
			}
		}else{																														// If the stick is pressed past the threshold, but the encoder is past a threshold:
			motor[mBlockStop] = 0;																					// Stop the motor
		}
																																			// FLAG RAISER
		if(btnFlagClock){																									// If the flag clockwise button is pressed:
			if(!btnFlagCounter){																						// If the flag counterclockwise button is NOT pressed:
				motor[mFlagRaise1] = 100;																			// Flag motors to 100
				motor[mFlagRaise2] = 100;
			}
		}else if(btnFlagCounter){																					// If the flag counterclockwise button is pressed:
			motor[mFlagRaise1] = -100;																			// Flag motors to -100
			motor[mFlagRaise2] = -100;
		}else{																														// If neither are pressed
			motor[mFlagRaise1] = 0;																					// Flag motors to 0
			motor[mFlagRaise2] = 0;
		}
																																			// CONVEYOR TENSION
		if(btnConveyorTight){																							// If the conveyor tension button is pressed:
			servo[rConveyorTight] = 170;																		// Servo to active position
		}else{																														// If the conveyor tension button is NOT pressed:
			servo[rConveyorTight] = 150;																		// Servo to retracted position
		}
																																			// BLOCK FLIPPERS
		if(nMotorEncoder[mBsAngle] > 3000){																// If the brick sucker is above a certain height:
			servo[rBlockDropLeft] = 128;																		// Move the brick suckers out of the way
			servo[rBlockDropRight] = 128;
		}else{																														// If the brick sucker is below a certain height:
			servo[rBlockDropLeft] = 32;																			// Retract the servos
			servo[rBlockDropRight] = 200;
		}
	}
}
